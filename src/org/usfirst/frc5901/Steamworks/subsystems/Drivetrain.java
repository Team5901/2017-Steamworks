// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5901.Steamworks.subsystems;


import org.usfirst.frc5901.Steamworks.Robot;
import org.usfirst.frc5901.Steamworks.RobotMap;
import org.usfirst.frc5901.Steamworks.commands.*;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Drivetrain extends Subsystem {
    private final SpeedController leftFrontMotor = RobotMap.drivetrainLeftFrontMotor;
    private final SpeedController rightFrontMotor = RobotMap.drivetrainRightFrontMotor;
    private final SpeedController leftRearMotor = RobotMap.drivetrainLeftRearMotor;
    private final SpeedController rightRearMotor = RobotMap.drivetrainRightRearMotor;
    private final ADXRS450_Gyro godKevinGyro = RobotMap.drivetrainGodKevinGyro;
    
    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //%%%%%%%%%% PARAMETERS %%%%%%%%%%
 	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    double Kp = 0.019; //0.019 ORIGINAL
    double KTurn = 0.02; //0.025 too high, .02 was pretty good .01 too low
    private static double precisionDriveAmount=0.7;
    
    
    //Sets motor outputs
	private void setMotorOutputs(double leftSpeed, double rightSpeed){
		leftFrontMotor.set(leftSpeed);
		rightFrontMotor.set(rightSpeed);
		leftRearMotor.set(leftSpeed);
		rightRearMotor.set(rightSpeed);
	}
	
	//Limits maximum turning rate
	private static double limitTurn(double num) {
        if (num > 0.5) {
            return 0.5;
        }
        else if (num < -0.5) {
            return -0.5;
        }
        else{
        	return num;
        }
    }
	
	//Limits maximum motor output to 1.0
	private static double limit(double num) {
        if (num > 1.0) {
            return 1.0;
        }
        else if (num < -1.0) {
            return -1.0;
        }
        else{
        	return num;
        }
    }
	
	//Deadzone for controller
    private static double deadzone(double num){
    	if (Math.abs(num) < 0.2){
    		return 0;
    	}
		else {
			return num;
    	}
    }
    public void arcadeDrive(double moveValue, double rotateValue) {
        double leftMotorSpeed;
        double rightMotorSpeed;
        
        moveValue = limit(moveValue);
        rotateValue = limit(rotateValue);

        leftMotorSpeed = moveValue + rotateValue; //0.85
        rightMotorSpeed = moveValue - rotateValue;
        setMotorOutputs((leftMotorSpeed), (rightMotorSpeed));
    }
	public void drive(){
		
		double move = Robot.oi.controller1.getRawAxis(1);
		double rotate = Robot.oi.controller1.getRawAxis(4);
		
        move = deadzone(move);
        rotate = deadzone(rotate);
		
		if (Robot.oi.controller1.getRawButton(6)){
			arcadeDrive(move, rotate);
		}
		else{					
			arcadeDrive(move*precisionDriveAmount, rotate*precisionDriveAmount);
		}		
	}
	
	public void stopDrive(){
		arcadeDrive(0.0,0.0);
	}
	public void autoTurn(double angleTarget){
		double angle = godKevinGyro.getAngle(); 						// get current heading
		arcadeDrive(0.0, -limitTurn((angle + angleTarget)*KTurn)); 		// turn towards angleTarget
		Timer.delay(0.004);	        
	}
	
	public void autoBackwards(double speed){
		 double angle = godKevinGyro.getAngle(); 			// get current heading
		 arcadeDrive(speed, -angle*Kp); 					// drive backwardsheading 0
		 Timer.delay(0.004);
	}
	
	public void autoStraight(double speed){
		 double angle = godKevinGyro.getAngle(); 			// get current heading
		 arcadeDrive(-speed, -angle*Kp); 					// drive towards heading 0
		 Timer.delay(0.004);
	}
	

    public void initDefaultCommand() {
        setDefaultCommand(new TeleopArcadeDriveCommand()); 	
    }
}

